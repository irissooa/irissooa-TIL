# 프론트엔드개발환경

[toc]

## 1. NPM

> [프론트엔드 개발환경의 이해 : NPM](https://jeonghwan-kim.github.io/series/2019/12/09/frontend-dev-env-npm.html)

### 1) 프론트엔드 개발에 Node.js가 필요한 이유?

- 최신 스펙으로 개발할 수 있다.
  - 자바스크립트 발전 > 브라우저 지원 속도
  - 웹팩, NPM 같은 노드 기술로 만들어진 환경에서 사용할 때 비로소 자동화된 프론트엔드 개발환경을 갖출 수 있다.
  - Typescript, SASS 또한 Node.js 환경이 뒷받침 되어야 된다.
- 빌드 자동화
  - 파일을 압축하고, 코드를 난독화하고, 폴리필을 추가하는 등 개발 이외의 작업을 거친 후 배포한다.
  - Node.js는 이런 빌드과정을 이해하게 하고, 라이브러리 의존성을 해결하고, 각종 테스트를 자동화하는데 사용된다.
- 개발 환경 커스터마이징
  - 커스터마이징을 하려면 Node.js 지식이 필요하다
  - Vue.js의 vue-cli, React.js의 CRA(create-react-app)를 사용하면 개발환경을 쉽게 갖출 수 있지만, 자동화된 도굴르 사용할 수 없는 환경이라면 직접 환경을 구축해야한다.

### 2) Node.js 설치

-  [Nodejs.org 사이트](https://nodejs.org/ko/)에서 노드 최신 버전을 설치가 가능하다.
- 짝수버전 : 안정적, 신뢰도 높음(LTS)
- 홀수버전 : 최신기능
- 개발환경이기 때문에 오른쪽 최신 버전을 선택해서 다운, Node.js로 서버를 구성하는 경우라면 어떤 버전을 사용할지 신중하게 선택(LTS)
- 터미널에 `node`를 치면 node.js를 쓸 수 있는`REPL(read-eval-print loop)` 프로그램이 실행됨
  - `.exit` 명령을 실행하거나 `ctrl + c`를 연속 두 번 입력하면 REPL 프로그램에서 빠져 나올 수 있다.

![image-20210527134313017](프론트엔드개발환경.assets/image-20210527134313017.png)

- Node를 설치하면 npm도 같이 설치된다.

### 3) 프로젝트 초기화

#### init

- `sample`폴더를 만든 뒤, 터미널에 `npm init`을 하면 프로젝트가 새로 생성된다.

```sh
$ npm init

package name:
version:
description:
entry point:
test command:
git repository:
keywords:
author:
license:
```

- 패키지 이름, 버전 등 프로젝트와 관련한 몇 가지 정보를 얻기 위한 질문을 볼 수 있다. 
- 답변하거나 혹은 빈 칸으로 남겨 두면 괄호 안의 기본값을 입력할 수 있다. 
- 모든 질문에 답하면 명령어를 실행한 폴더에 pacakge.json 파일이 생성된다. 
- 모두 기본값을 사용할 것이라면 `npm init -y` 명령어로 질문을 스킵하고 package.json 파일을 생성할 수 있다.

#### Package.json

- name: 프로젝트 이름
- version: 프로젝트 버전 정보
- description: 프로젝트 설명
- main: 노드 어플리케이션일 경우 진입점 경로. 프론트엔드 프로젝트일 경우 사용하지 않는다.
- scripts: 프로젝트 명령어를 등록할 수 있다.초기화시 test 명령어가 샘플로 등록되어 있다
- author: 프로그램 작성자
- license: 라이센스

```json
{
  "name": "sample",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
    // npm 명령어를 추가할 수 있다, 기본적으로 제공해주는 명령어 외에 추가하고 싶다면, scripts안에 추가!
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
      // 명령어추가
     "build" : "echo \"여기에 빌드 스크립트를 추가합니다\""
  },
  "author": "",
  "license": "ISC"
}
```

### 4) 프로젝트 명령어

- 기본적으로 제공해주는 명령어외에 추가하고 싶다면 `scripts`안에 추가한 뒤, `npm run 명령어`를 터미널창에 치면, 실행된다.
- test: echo 명령어로 메세지 "Error: no test specified"를 출력한뒤 에러 코드 1을 던지면서 종료하는 동작이다. 에러 코드 1을 확인하면 에러("npm ERR!...")를 출력한다.

![image-20210527134828652](프론트엔드개발환경.assets/image-20210527134828652.png)

![image-20210527135150865](프론트엔드개발환경.assets/image-20210527135150865.png)

#### NPM 명령어

- start: 어플리케이션 실행
- test: 테스트
- install: 패키지 설치
- uninstall: 패키지 삭제
- 프론트엔드 개발 환경을 구축하기 위해 추가할 스크립트는 build, lint 정도가 있다.
  - build: 소스 빌드
  - lint: 소스 컨벤션 검사

```sh
Usage: npm <command>

where <command> is one of:
    access, adduser, audit, bin, bugs, c, cache, ci, cit,
    clean-install, clean-install-test, completion, config,
    create, ddp, dedupe, deprecate, dist-tag, docs, doctor,
    edit, explore, get, help, help-search, hook, i, init,
    install, install-ci-test, install-test, it, link, list, ln,
    login, logout, ls, org, outdated, owner, pack, ping, prefix,
    profile, prune, publish, rb, rebuild, repo, restart, root,
    run, run-script, s, se, search, set, shrinkwrap, star,
    stars, start, stop, t, team, test, token, tst, un,
    uninstall, unpublish, unstar, up, update, v, version, view,
    whoami
```

### 5) 패키지 설치

#### CDN(컨텐츠 전송 네트워크)을 이용한 방법

- CDN 서버 장애로 인해 외부 라이브러리를 사용할 수 없다면  웹 어플리케이션은 정상적으로 동작하지 않을 것이다

#### 직접 다운로드하는 방법

- CDN을 사용하지 않기 때문에 장애와 독립적으로 웹 어플리케이션을 제공.

- 라이브러리는 계속해서 업데이트 될 것이고 우리 프로젝트에서도 최신 버전으로 교체해야 한다. 매번 직접 다운로드해야하며, 버전에 따라 하위 호환성 여부까지 확인하려면 실수할 여지가 많다.

#### NPM을 이용한 방법

- `npm install` 명령어로 외부 패키지를 우리 프로젝트 폴더에 다운로드가 된다.

```sh
$ npm install react
```

- 최신 버전의 react를 [NPM 저장소](https://www.npmjs.com/)에서 찾아 우리 프로젝트로 다운로드 하는 명령어다. package.json에는 설치한 패키지 정보를 기록한다.

- package.json:

```json
{
  "dependencies": {
   // 버전 16.12.0을 설치했다는 의미 
     "react": "^16.12.0"
  }
}
```

##### `^` : 유의적 버전

- 만약 프로젝트에서 사용하는 패키지의 버전을 엄격하게 제한한다면 사용하는 패키지를 전부 버전업해야 하기 때문에 프로젝트 버전업이 힘들 수 있고, 현재 버전에 갖혀 버릴 수도 있다.
- 반면에, 패키지 버전을 느슨하게 풀어 놓으면 오히려 여러 버전별로 코드를 관리해야하는 혼란스러움을 겪게될 수 있다.
- 버전번호를 관리하기 위한 규칙 **유의적 버전(Semetic-Version)** 이라고 한다.
- 유의적 버전은 주(Major), 부(Minor), 수(Patch) 세 가지 숫자를 조합해 버전을 관리한다.
  - 16.12.0 : 주 버전이 16, 부 버전이 12, 수 버전이 0이다.
  - 주 버전(Major Version): 기존 버전과 호환되지 않게 변경한 경우
  - 부 버전(Minor version): 기존 버전과 호환되면서 기능이 추가된 경우
  - 수 버전(Patch version): 기존 버전과 호환되면서 버그를 수정한 경우

#### 버전의 범위

- NPM이 버전을 관리하는 방식은 유의적 버전 명세 뿐만아니라 버전의 범위를 자신만의 규칙으로 관리
- 특정 버전보다 높거나 낮을 경우

```sh
>1.2.3
>=1.2.3
<1.2.3
<=1.2.3
```

- 틸드(`~`)와 캐럿(`^`)

  ##### 틸드(`~`)

  - 마이너 버전이 명시되어 있으면 패치버전만 변경
  - 예를 들어 ~1.2.3 표기는 1.2.3 부터 1.3.0 미만 까지를 포함한다. 
  - 마이너 버전이 없으면 마이너 버전을 갱신한다. ~0 표기는 0.0.0부터 1.0.0 미만 까지를 포함한다.

  ##### 캐럿(`^`)

  - 정식버전에서 마이너와 패치 버전을 변경한다. 
  - 예를 들어 ^1.2.3 표기는 1.2.3부터 2.0.0 미만 까지를 포함한다. 
  - 정식버전 미만인 0.x 버전은 패치만 갱신한다. ^0 표기는 0.0.0부터 0.1.0 미만 까지를 포함한다.

- 보통 라이브러리 정식 릴리즈 전에는 패키지 버전이 수시로 변한다.
  - 부버전이 변하더라도 하위 호환성을 지키지 않고 배포하는 경우가 빈번하다
  - `~0`으로 버전 범위를 표기하면 `0.0.0`부터 `1.0.0`미만까지 사용하기 때문에 하위 호완성을 지키지 못하는 `0.2`로도 업데이트 되어버리는 문제가 생길 수 있다.
  - 반면 `^0.0`으로 표기한다면 `0.0.0`부터 `0.1.0` 미만 내에서만 버전을 사용하도록 제한해 하위 호완성을 유지할 수 있다.
- NPM으로 패키지를 설치하면 `package.json`에 설치한 버전을 기록하는데 **캐럿 방식**을 이용한다.



## 2.  웹팩

> [프론트엔드 개발환경의 이해 : 웹팩](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html)

### 1) 웹팩이 필요한 이유

이전에는 

`math.js`

```js
function sum(a, b) {
  return a + b
} // 전역 공간에 sum이 노출
```

`app.js`

```js
sum(1, 2) // 3
```

위 코드는 모두 하나의 HTML 파일 안에서 로딩해야만 실행된다. 

`index.html`

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script src="src/math.js"></script>
  <script src="src/app.js"></script>
</body>
</html>
```

math.js가 로딩되면 app.js는 이름 공간에서 'sum'을 찾은 뒤 이 함수를 실행한다. 문제는 'sum'이 전역 공간에 노출된다는 것. 다른 파일에서도 'sum'이란 이름을 사용한다면 충돌한다.

![image-20210607101930468](프론트엔드개발환경.assets/image-20210607101930468.png)

![image-20210607102023524](프론트엔드개발환경.assets/image-20210607102023524.png)

자바스크립트는 아래처럼 sum에 접근할 수 있고, 자바스크립트는 이런 함수 타입에 다른 값을 할당 할 수 있다. 할당한 뒤, 다시 sum함수를 호출하면 이렇게 타입에러가 발생한다. 이렇게 전역 스코프가 오염되면 어플리케이션이 예측을 할 수 없게 되고  **런타임에러가 발생한다.**

![image-20210607102058516](프론트엔드개발환경.assets/image-20210607102058516.png)

이런 문제를 해결하기 위해 **IIFE방식(즉시 실행 함수 표현)의 모듈을 사용한다.**

#### 1) IIFE 방식의 모듈

이러한 문제를 예방하기 위해 스코프를 사용한다. **함수 스코프를 만들어 외부에서 안으로 접근하지 못하도록 공간을 격리하는 것**이다. 스코프 안에서는 자신만의 이름 공간이 존재하므로 스코프 외부와 이름 충돌을 막을 수 있다.

`math.js`

```js
var math = math || {} // math 네임스페이스

;(function () {
  function sum(a, b) {
    return a + b
  }
  math.sum = sum // 네이스페이스에 추가
})()
```

같은 코드를 즉시실행함수로 감쌌기 때문에 다른 파일에서 이 안으로 접근할 수가 없다. 심지어 같은 파일일지라도 말이다. 자바스크립트 함수 스코프의 특징이다. 'sum'이란 이름은 즉시실행함수 안에 감추어졌기 때문에 외부에서는 같은 이름을 사용해도 괜찮다. 전역에 등록한 'math'라는 이름 공간만 잘 활용하면 된다.

`app.js`

```javascript
console.log(math.sum(1,2));
```



#### 2) 다양한 모듈 스펙

이러한 방식으로 자바스크립트 모듈을 구현하는 대표적인 명세가 AMD와 CommonJS다.

**[CommonJS](http://www.commonjs.org/)**는 자바스크립트를 사용하는 모든 환경에서 모듈을 하는 것이 목표다. exports 키워드로 모듈을 만들고 **require()** 함수로 불러 들이는 방식이다. 대표적으로 서버 사이드 플래폼인 Node.js에서 이를 사용한다.

`math.js`:

```js
exports function sum(a, b) { return a + b; }
```

`app.js`:

```js
const math = require("./math.js")
math.sum(1, 2) // 3
```

**[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)**(Asynchronous Module Definition)는 비동기로 로딩되는 환경에서 모듈을 사용하는 것이 목표다. 주로 브라우져 환경이다.

**[UMD](https://github.com/umdjs/umd)**(Universal Module Definition)는 AMD기반으로 CommonJS 방식까지 지원하는 통합 형태다.

이렇게 각 커뮤니티에서 각자의 스펙을 제안하다가 **[ES2015에서 표준 모듈 시스템](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)**을 내 놓았다. 지금은 바벨과 웹팩을 이용해 모듈 시스템을 사용하는 것이 일반적이다. 

##### ES2015 모듈 시스템

math.js:

```js
export function sum(a, b) {
  return a + b
}
```

app.js:

> `*`는 math안의 모두를 가져온다. sum만 가져오고 싶다면 `import {sum} from './math.js'`라고 쓰면 된다

```js
import * as math from "./math.js" 
math.sum(1, 2) // 3
```

`export` 구문으로 모듈을 만들고 `import` 구문으로 가져올 수 있다.

#### 3) 브라우져의 모듈 지원

모든 브라우져에서 모듈 시스템을 지원하지는 않는다. 인터넷 익스플로러를 포함한 몇 몇 브라우져에서는 여전히 모듈을 사용하지 못한다. 가장 많이 사용하는 크롬 브라우져만 잠시 살펴보자. ([버전 61부터 모듈시스템을 지원](https://developers.google.com/web/updates/2017/09/nic61#modules) 한다)

`index.html`:

```html
<script type="module" src="app.js"></script>
```

> `<script>`태그로 로딩할 때 type="text/javascript" 대신 type="module"을 사용한다. app.js는 모듈을 사용할 수 있다.
>
> 이렇게 모듈로 한 뒤 터미널에 `open index.html`을 하면 `CORS`에러가 난다.
>
> 브라우저가 바로 파일을 읽지 않고 서버를 돌려야한다.
>
> `lite-server`는 node패키지인데 `npx lite-server`를 하면 해당 파일을 서버를 간단하게 돌릴 수 있다.

그러나 브라우져에 무관하게 모듈을 사용하고 싶다면 이제 웹팩이 나올 차례다.

### 2) 엔트리/아웃풋

> [웹팩](https://webpack.js.org/)은 여러개 파일을 하나의 파일로 합쳐주는 번들러(bundler)다. 
>
> 하나의 시작점(entry point)으로부터 의존적인 모듈을 전부 찾아내서 하나의 결과물을 만들어 낸다. app.js부터 시작해 math.js 파일을 찾은 뒤 하나의 파일로 만드는 방식이다.

번들 작업을 하는 [webpack](https://github.com/webpack/webpack) 패키지와 웹팩 터미널 도구인 [webpack-cli](https://github.com/webpack/webpack-cli)를 설치한다.

> 웹팩 버전을 설정해주려면 `webpack@4`(4버전으로 설치하겠다)라고 명시해주면 된다.

```text
$ npm install -D webpack webpack-cli
```

설치 완료하면 `node_modules/.bin` 폴더에 실행 가능한 명령어가 몇 개 생긴다. 

webpack과 webpack-cli가 있는데 둘 중 하나를 실행하면 된다.

#####  `--help` 옵션으로 사용 방법

```text
$ node_modules/.bin/webpack --help

  --mode                 Enable production optimizations or development hints.
                                     [선택: "development", "production", "none"]
  --entry      The entry point(s) of the compilation.                   [문자열]
  --output, -o                  The output path and file for compilation assets
```

`--mode`, `--entry`, `--output` 세 개 옵션만 사용하면 코드를 묶을 수 있다.

```text
$ node_modules/.bin/webpack --mode development --entry ./src/app.js --output dist/main.js
```

- `--mode`는 웹팩 실행 모드는 의미하는데 개발 버전인 `development`를 지정한다
- `--entry`는 시작점 경로를 지정하는 옵션이다
- `--output`은 번들링 결과물을 위치할 경로다

위 명령어를 실행하면 dist/main.js에 번들된 결과가 저장된다.

> `--help` 해본 결과 `--output-path`가 웹팩 번들 결과가 저장되는 path를 설정하는 명령어였다.

![image-20210607110834938](프론트엔드개발환경.assets/image-20210607110834938.png)이 코드를 index.html에 로딩하면 번들링 전과 똑같은 결과를 만든다.

index.html:

```html
<script src="dist/main.js"></script>
```

옵션 중 `--config` 항목을 보자.

```text
$ node_modules/.bin/webpack --help

  --config               Path to the config file
                         [문자열] [기본: webpack.config.js or webpackfile.js]
```

이 옵션은 웹팩 설정파일의 경로를 지정할 수 있는데 기본 파일명이 `webpack.config.js` 혹은 webpackfile.js다. `webpack.config.js` 파일을 만들어 방금 터미널에서 사용한 옵션을 코드로 구성해 보자.

webpack.config.js:

```js
const path = require("path") // path 절대경로를 가져온다.

module.exports = {
  mode: "development",
  entry: {
    main: "./src/app.js",
  },
  output: {
    filename: "[name].js",
    path: path.resolve("./dist"),
  },
}
```

터미널에서 사용한 옵션인 mode, entry, ouput을 설정한다.

- `mode`는 'development' 문자열을 사용했다.
- `entry`는 어플리케이션 진입점인 src/app.js로 설정한다.
- `ouput`에 설정한 '[name]'은 entry에 추가한 main이 문자열로 들어오는 방식이다.
  - `output.path`는 절대 경로를 사용하기 때문에 path 모듈의 resolve() 함수를 사용해서 계산했다. (path는 노드 코어 모듈 중 하나로 경로를 처리하는 기능을 제공한다)

웹팩 실행을 위한 NPM 커스텀 명령어를 추가한다.

`package.json`:

```json
{
  "scripts": {
    "build": "webpack" //  현재 프로젝트 있는 webpack파일을 읽어 실행함
  }
}
```

모든 옵션을 웹팩 설정 파일로 옮겼기 때문에 단순히 webpack 명령어만 실행한다. 이제부터는 `npm run build`로 웹팩 작업을 지시할 수 있다.



#### 실습

##### (1) 웹팩으로 빌드한 자바스크립트 로딩

1. 터미널에 `npm init -y`를 입력한다. (기본값을 다 사용해서 package.json 파일을 만든다.)
2. webpack 패키지를 설치한다. `npm install -D webpack webpack-cli`
3. package.json 파일에서 scripts에 build 명령어를 `webpack`으로 설정한다.

```json
{
  "scripts": {
    "build": "webpack"
  }
}
```

3. `webpack.config.js`파일을 프로젝트 상단에 만든다.

> ES6가 아니라 node가 사용하는 모듈시스템이라 `module.exports`를 쓴다는 것을 유념해야된다.

```javascript
const path = require('path');

module.exports = {
    mode: 'development',
    entry: {
        main: './src/app.js'
    },
    output: {
        filename: '[name].js',
        path: path.resolve('./dist')
    }
}
```

4. 터미널에 `npm run build`를 실행한다.
5. dist 폴더에 `main.js` 파일에 번들링 된 결과가 나온다. 해당 파일을 `index.html`에 로딩을 하면 된다.

```html
<body>
    <script src="./dist/main.js"></script>
</body>
```

6. 그리고 터미널에 `open index.html`을 통해 index파일을 연다

![image-20210607114433284](프론트엔드개발환경.assets/image-20210607114433284.png)



### 3) 로더

#### (1) 로더의 역할

웹팩은 모든 파일을 모듈로 바라본다. 자바스크립트로 만든 모듈 뿐만아니라 스타일시트, 이미지, 폰트까지도 전부 모듈로 보기 때문에 import 구문을 사용하면 자바스크립트 코드 안으로 가져올수 있다.

이것이 가능한 이유는 웹팩의 **로더** 덕분이다. 로더는 타입스크립트 같은 다른 언어를 자바스크립트 문법으로 변환해 주거나 이미지를 data URL 형식의 문자열로 변환한다. 뿐만아니라 CSS 파일을 자바스크립트에서 직접 로딩할수 있도록 해준다.

#### (2) 커스텀 로더 만들기

로더를 사용하기 전에 동작 원리를 이해하기 위해 로더를 직접 만들어 보자.

`my-webpack-loader.js`:

```js
module.exports = function myWebpackLoader(content) {
  console.log("myWebpackLoader가 동작함");
  return content;
}
```

함수로 만들수 있는데 로더가 읽은 파일의 내용이 함수 인자 content로 전달된다. 로더가 동작하는지 확인하는 용도로 로그만 찍고 곧장 content를 돌려 준다.

로더를 사용하려면 웹팩 설정파일의 `module` 객체에 추가한다.

`webpack.config.js`:

```js
module: {
  rules: [{
    test: /\.js$/, // .js 확장자로 끝나는 모든 파일에 이 로더를 적용하겠다.
    use: [
        path.resolve('./my-webpack-loader.js')
    ] // 방금 만든 로더를 적용한다
  }],
}
```

`module.rules` 배열에 모듈을 추가하는데 test와 use로 구성된 객체를 전달한다.

- `test`
  - 로딩에 적용할 파일을 지정한다. 
  - 파일명 뿐만아니라 파일 패턴을 정규표현식으로 지정할수 있는데 위 코드는 `.js` 확장자를 갖는 모든 파일을 처리하겠다는 의미다.

- `use`
  - 이 패턴에 해당하는 파일에 적용할 로더를 설정하는 부분이다. 
  - 방금 만든 `myWebpackLoader` 함수의 경로를 지정한다.

이제 `npm run build`로 웹팩을 실행해 보자.

![image-20210607115807664](프론트엔드개발환경.assets/image-20210607115807664.png)

터미널에 'myWebpackLoader가 동작함' 문자열이 찍힌다. `myWebpackLoader()` 함수가 동작한 것이다.

두 번 찍히는 이유는 모든 js파일마다 로더가 한번씩 실행되게 했기 때문에 app.js와 math.js에서 두번 실행되기 때문이다.

빌드결과를 살펴보면 이전과 동일하다. 로더가 뭔가를 처리하기 위해서 간단한 변환 작업을 추가해 보자. 소스에 있는 모든 console.log() 함수를 alert() 함수로 변경하도록 말이다.

`my-webpack-loader.js`:

```js
module.exports = function myWebpackLoader(content) {
  console.log("myWebpackLoader가 동작함");
  return content.replace("console.log(", "alert("); // console.log( -> alert( 로 치환
}
```

빌드후 확인하면 다음과 같이 console.log() 함수가 alert() 함수로 변경되었다.

![image-20210607120158391](프론트엔드개발환경.assets/image-20210607120158391.png)

### 4) 자주 사용하는 로더

로더의 동작 원리를 살펴 보았으니 이번에는 몇몇 자주 사용하는 로더를 소개하겠다.

#### (1) css-loader

웹팩은 모든것을 모듈로 바라보기 때문에 자바스크립트 뿐만 아니라 스타일시트로 import 구문으로 불러 올수 있다.

`app.js`:

```js
import "./style.css"
```

`style.css`:

```css
body {
  background-color: green;
}
```

CSS 파일을 자바스크립트에서 불러와 사용하려면 CSS를 모듈로 변환하는 작업이 필요하다. [css-loader](https://github.com/webpack-contrib/css-loader)가 그러한 역할을 하는데 우리 코드에서 CSS 파일을 모듈처럼 불러와 사용할 수 있게끔 해준다.

먼저 로더를 설치 하자.

```text
$ npm install -D css-loader
```

웹팩 설정에 로더를 추가한다.

`webpack.config.js`:

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/, // .css 확장자로 끝나는 모든 파일
        use: ["css-loader"], // css-loader를 적용한다
      },
    ],
  },
}
```

웹팩은 엔트리 포인트부터 시작해서 모듈을 검색하다가 CSS 파일을 찾으면 css-loader로 처리할 것이다. use.loader에 로더 경로를 설정하는 대신 배열에 로더 이름을 문자열로 전달해도 된다.

빌드 한 결과 CSS코드가 자바스크립트로 변환된 것을 확인할 수 있다.

![웹팩 번들 결과](프론트엔드개발환경.assets/css-loader.jpg)

그런데 index.html을 열어보면 배경이 초록으로 적용이 안됐다.

html 코드가 DOM이라는 모습으로 변환되어야 브라우저에서 문서가 보이듯, css코드도 css om이라는 형태로 바뀌어야 적용된다.

#### (2) style-loader

모듈로 변경된 스타일 시트는 돔에 추가되어야만 브라우져가 해석할 수 있다. css-loader로 처리하면 자바스크립트 코드로만 변경되었을 뿐 돔에 적용되지 않았기 때문에 스트일이 적용되지 않았다.

[style-loader](https://github.com/webpack-contrib/style-loader)는 **자바스크립트로 변경된 스타일을 동적으로 돔에 추가하는 로더**이다. CSS를 번들링하기 위해서는 css-loader와 style-loader를 **함께** 사용한다.

먼저 스타일 로더를 다운로드 한다.

```text
$ npm install -D style-loader
```

그리고 웹팩 설정에 로더를 추가한다.

`package.json`:

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ["style-loader", "css-loader"], // style-loader를 앞에 추가한다
      },
    ],
  },
}
```

배열로 설정하면 **뒤에서부터 앞으로 순서대로 로더가 동작**한다. 위 설정은 모든 .css 확장자로 끝나는 모듈을 읽어 들여 css-loader를 적용하고 그 다음 style-loader를 적용한다.

![웹팩 번들 결과](프론트엔드개발환경.assets/style-loader.jpg)



#### (3) file-loader

CSS 뿐만 아니라 소스코드에서 사용하는 모든 파일을 모듈로 사용하게끔 할 수 있다. 파일을 모듈 형태로 지원하고 웹팩 아웃풋에 파일을 옮겨주는 것이 [file-loader](https://github.com/webpack-contrib/file-loader)가 하는 일이다. 가령 CSS에서 url() 함수에 이미지 파일 경로를 지정할 수 있는데 웹팩은 file-loader를 이용해서 이 파일을 처리한다.

`style.css`:

```css
body {
  background-image: url(bg.png);
}
```

배경 이미지를 bg.png 파일로 지정했다.

웹팩은 엔트리 포인트인 app.js가 로딩하는 style.css 파일을 읽을 것이다. 그리고 이 스타일시트는 url() 함수로 bg.png를 사용하는데 이때 로더를 동작시킨다.

`webpack.config.js`:

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.png$/, // .png 확장자로 마치는 모든 파일
        loader: "file-loader", // 파일 로더를 적용한다
      },
    ],
  },
}
```

웹팩이 .png 파일을 발견하면 file-loader를 실행할 것이다. 로더가 동작하고 나면 아웃풋에 설정한 경로로 이미지 파일을 복사된다. 아래 그림처럼 파일명이 해쉬코드로 변경 되었다. 웹팩은 빌드를 할 때마다 유니크한 값을 생성하는데 그게 앞에 있는 이 해쉬값이다. 캐쉬 갱신을 위한 처리로 보인다. 파일 내용이 다른데 이름이 같으면 이전 값을 브라우저가 사용하기 때문에 이런 것을 예방하는 방법 중 하나가 이름을 변경하는 것이다.

![웹팩 번들 결과](프론트엔드개발환경.assets/file-loader.jpg)



하지만 이대로 index.html 파일을 브라우져에 로딩하면 이미지를 제대로 로딩하지 못할 것이다. CSS를 로딩하면 `background-image: url(bg.png)` 코드에 의해 동일 폴더에서 이미지를 찾으려고 시도할 것이다. 그러나 웹팩으로 빌드한 이미지 파일은 output인 dist 폴더 아래로 이동했기 때문에 이미지 로딩에 실패할 것이다.

file-loader 옵션을 조정해서 경로를 바로 잡아 주어야 한다.

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.png$/, // .png 확장자로 마치는 모든 파일
        loader: "file-loader",
        options: {
          publicPath: "./dist/", // prefix를 아웃풋 경로로 지정
          name: "[name].[ext]?[hash]", // 파일명 형식
        },
      },
    ],
  },
}
```

- `publicPath` 옵션
  -  file-loader가 처리하는 파일을 모듈로 사용할 때 경로 앞에 추가되는 문자열이다. 
  - output에 설정한 'dist' 폴더에 이미지 파일을 옮길 것이므로 publicPath 값을 이것으로로 지정했다. 
  - 파일을 사용하는 측에서는 'bg.png'를 'dist/bg.png'로 변경하여 사용할 것이다.

- `name` 옵션
  - 이것은 로더가 파일을 아웃풋에 복사할때 사용하는 파일 이름이다. 
  - hash는 매번 달라지는 hash값으로 변경되도록 설정했다.
  - 기본적으로 설정된 해쉬값을 쿼리스트링으로 옮겨서 'bg.png?6453a9c65953c5c28aa2130dd437bbde' 형식으로 파일을 요청하도록 변경했다.

![파일로더 결과 2](프론트엔드개발환경.assets/file-loader-2.jpg)

이렇게 스타일시트에서 불러온 파일이 동작한다.

![image-20210607122219868](프론트엔드개발환경.assets/image-20210607122219868.png)

#### (4) url-loader

사용하는 이미지 갯수가 많다면 네트웍 리소스를 사용하는 부담이 있고 사이트 성능에 영향을 줄 수도 있다. **만약 한 페이지에서 작은 이미지를 여러 개 사용한다면** [Data URI Scheme](https://en.wikipedia.org/wiki/Data_URI_scheme)을 이용하는 방법이 더 나은 경우도 있다. 이미지를 Base64로 인코딩하여 문자열 형태로 소스코드에 넣는 형식이다.

[url-loader](https://github.com/webpack-contrib/url-loader)는 이러한 처리를 자동화해준다.

- `app.js`

```javascript
import './style.css';
import nyancat from './nyancat.jpg';

document.addEventListener('DOMContentLoaded',() => {
    document.body.innerHTML = `
		<img src="${nyancat}"/>`
})
```

이렇게 하면 build를 할 때 저장이 된다.

![image-20210607122847230](프론트엔드개발환경.assets/image-20210607122847230.png)

하지만 작은 파일은 `url-loader`를 사용하는 것이 좋다.

먼저 로더를 설치한다.

```text
$ npm install -D url-loader
```

그리고 웹팩 설정을 추가한다.

 `webpack.config.js`:

```js
{
  test: /\.(png|jpg|gif|svg)$/,
  use: {
    loader: 'url-loader', // url 로더를 설정한다
    options: {
      publicPath: './dist/', // file-loader와 동일
      name: '[name].[ext]?[hash]', // file-loader와 동일
      limit: 5000 // 5kb 미만 파일만 data url로 처리
    }
  }
}
```

file-loader와 옵션 설정이 거의 비슷하고 마지막 `limit` 속성만 추가했다. 모듈로 사용한 파일중 크기가 5kb 미만인 파일만 url-loader를 적용하는 설정이다. 만약 이보다 크면 file-loader가 처리하는데 옵션 중 [fallback](https://github.com/webpack-contrib/url-loader#options) 기본값이 file-loader이기 때문이다.

**빌드 결과를 보면 small.png 파일이 문자열로 변경되어 있는 것을 확인 할 수 있다. 반면 5kb 이상인 bg.png는 여전히 파일로 존재한다.**

![image-20210607123127918](프론트엔드개발환경.assets/image-20210607123127918.png)

![url 로더 결과 1](프론트엔드개발환경.assets/url-loader-1.jpg)브라우저에서도 확인하면 스타일스트에 small.png가 Data url형태로 변환되어 있다.

![url 로더 결과 2](프론트엔드개발환경.assets/url-loader-2.jpg)

아이콘처럼 용량이 작거나 사용 빈도가 높은 이미지는 파일을 그대로 사용하기 보다는 Data URI Scheeme을 적용하기 위해 url-loader를 사용하면 좋다.

![image-20210607122711031](프론트엔드개발환경.assets/image-20210607122711031.png)

#### 실습

##### css파일을 엔트리포인트(app.js)에서 로딩, 웹팩에서 로딩할수 있도록 로더를 설정해야된다.

1. css 파일을 웹팩에서 로딩하기 위해 보통 style-loader와 css-loader가 필요하다.

```sh
$ npm install style-loader css-loader
```

2. `webpack.config.js`

```javascript
const path = require('path');

module.exports = {
    mode:'development',
    entry: {
        main:'./src/app.js'
    },
    output: {
        filename: '[name].js'm
        path: path.resolve.('./dist'),
    },
    // 로더를 등록할 때는 모듈 객체를 추가
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ['style-loader','css-loader'] // 순서가 중요!(css-loader를 먼저 쓰고, style-loader를 쓴다.)
            }
        ]
    }
}
```

3. 이렇게 설정하면 `app.js`에서 `main.css`를 가져올 수 있다.

```javascript
import MainController from './controllers/MainController.js';
// 이렇게 가져올 수 있음
import './main.css';

document.addEventListener("DOMControlLoaded", ()=>{
    new MainController();
});
```



##### 파일을 로딩할 수 있도록 웹팩 로더 설정을 추가(file-loader나 image-loader)

1. `ResultView.js`파일 에서 아래처럼 `defaultImage`를 불러오려면 `file-loader`나 `image-loader`가 필요하다.

```javascript
import View from './View.js';
import defaultImage from '../images/default-image.jpg';
```

2. `file-loader`를 설치

```sh
$ npm install file-loader
```

3. `webpack.config.js`

```javascript
const path = require('path');

module.exports = {
    mode:'development',
    entry: {
        main:'./src/app.js'
    },
    output: {
        filename: '[name].js'm
        path: path.resolve.('./dist'),
    },
    // 로더를 등록할 때는 모듈 객체를 추가
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ['style-loader','css-loader']
            },
            // file-loader 추가
            {
                test: /\.(jpg|png)$/,
                loader: 'file-loader',
                options: {
                    name:'[name].[ext]?[hash]',
                    publicPath:'./dist' //prefix를 준다.
                }
            }
        ]
    }
}
```

4. 크기가 작은 이미지는 url로 표시하자

```sh
$npm install url-loader
```

5. file-loader를 url-loader로 바꾼다.

```javascript
const path = require('path');

module.exports = {
    mode:'development',
    entry: {
        main:'./src/app.js'
    },
    output: {
        filename: '[name].js'm
        path: path.resolve.('./dist'),
    },
    // 로더를 등록할 때는 모듈 객체를 추가
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ['style-loader','css-loader']
            },
            // file-loader 추가
            {
                test: /\.(jpg|png)$/,
                loader: 'url-loader',
                options: {
                    name:'[name].[ext]?[hash]',
                    publicPath:'./dist', //prefix를 준다.
                    limit: 10000, //10kb미만은 url로 표시하고, 그 이상은 file-loader가 처리한다.
                }
            }
        ]
    }
}
```

6. 빌드를 해보자

### 5) 플러그인

#### (1) 플러그인의 역할

웹팩에서 알아야 할 마지막 기본 개념이 플러그인이다. 로더가 파일 단위로 처리하는 반면 플러그인은 **번들된 결과물을 처리**한다. 번들된 자바스크립트를 난독화 한다거나 특정 텍스트를 추출하는 용도로 사용한다.

이것도 사용하기에 앞서 동작 원리를 이해하기 위해 플러그인을 직접 만들어 보자.

#### (2) 커스텀 플러그인 만들기

웹팩 문서의 [Writing a plugin](https://webpack.js.org/contribute/writing-a-plugin/)을 보면 클래스로 플러그인을 정의 하도록 한다. [헬로월드 코드](https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture)를 가져다 그대로 실행 붙여보자.

`myplugin.js`:

> 자바스크립트에서 class를 만들때 보통 앞에 대문자를 사용

```js
class MyPlugin {
  apply(compiler) {
    compiler.hooks.done.tap("My Plugin", stats => {
      console.log("MyPlugin: done")
    })
  }
}

module.exports = MyPlugin
```

로더와 다르게 플러그인은 클래스로 제작한다. apply 함수를 구현하면 되는데 이 코드에서는 인자로 받은 compiler 객체 안에 있는 tap() 함수를 사용하는 코드다. 플러그인 작업이 완료되는(done) 시점에 로그를 찍는 코드인것 같다.

플러그인을 웹팩 설정에 추가한다.

`webpack.config.js`:

```js
// 플러그인 파일을 가져옴
const MyPlugin = require("./myplugin")

module.exports = {
  // 가져온 MyPlugin 생성자 함수를 plugins배열에 new를 이용해 생성해줌
  plugins: [new MyPlugin()],
}
```

웹팩 설정 객체의 `plugins` 배열에 설정한다. 클래스로 제공되는 플러그인의 생성자 함수를 실행해서 넘기는 방식이다.

웹팩으로 빌드해 보자.

![myplugin](프론트엔드개발환경.assets/myplugin.jpg)



로그가 찍힌걸 보니 플러그인이 동작했다.

그런데 파일이 여러 개인데 로그는 한 번만 찍혔다. 모듈이 파일 하나 혹은 여러 개에 대해 동작하는 반면 플러그인은 하나로 번들링된 결과물을 대상으로 동작 한다. 우리 예제에서는 main.js로 결과물이 하나이기 때문에 플러그인이 한 번만 동작한 것이라 추측할 수 있다.

그러면 어떻게 번들 결과에 접근할 수 있을까? 웹팩 내장 플러그인 [BannerPlugin 코드](https://github.com/lcxfs1991/banner-webpack-plugin/blob/master/index.js)를 참고하자.

`myplugin.js`:

```js
class MyPlugin {
  apply(compiler) {
    compiler.hooks.done.tap("My Plugin", stats => {
      console.log("MyPlugin: done")
    })

    // compiler.plugin() 함수로 후처리한다
    compiler.plugin("emit", (compilation, callback) => {
      const source = compilation.assets["main.js"].source()
      console.log(source)
      callback()
    })
  }
}
```

compiler.plugin() 함수의 두번재 인자 콜백함수는 emit 이벤트가 발생하면 실행된다. 번들된 결과가 compilation 객체에 들어 있는데 `compilation.assets['main.js'].source()` 함수로 접근할 수 있다. 실행하면 터미널에 번들링된 결과물을 확인할 수 있다.

![myplugin](프론트엔드개발환경.assets/myplugin-2.jpg)이걸 이용해서 번들 결과 상단에 아래와 같은 배너를 추가하는 플러그인으로 만들어 보자.

myplugin.js:

```js
class MyPlugin {
  apply(compiler) {
    compiler.plugin('emit', (compilation, callback) => {
      const source = compilation.assets['main.js'].source();
      compilation.assets['main.js'].source = () => {
        const banner = [
          '/**',
          ' * 이것은 BannerPlugin이 처리한 결과입니다.',
          ' * Build Date: 2019-10-10',
          ' */'
          ''
        ].join('\n');
        return banner + '\n' + source;
      }

      callback();
    })
  }
}
```

번들 소스를 얻어오는 함수 source()를 재정의 했다. 배너 문자열과 기존 소스 코드를 합친 문자열을 반환하도록 말이다.

빌드하고 결과물을 확인해 보면 다음과 같다.

![myplugin 3](프론트엔드개발환경.assets/myplugin-3.jpg)

### 6) 자주 사용하는 플러그인

개발하면서 플러그인을 직접 작성할 일은 거의 없었다. 웹팩에서 직접 제공하는 플러그인을 사용하거나 써드파티 라이브러리를 찾아 사용하는데 자주 사용하는 플러그인에 대해 알아보자.

#### (1) BannerPlugin

MyPlugin와 비슷한 것이 [BannerPlugin](https://webpack.js.org/plugins/banner-plugin/)이다. 결과물에 빌드 정보나 커밋 버전같은 걸 추가할 수 있다.

`webpack.config.js`:

```js
const webpack = require('webpack'); // webpack모듈을 가져와 webpack이란 이름을 붙임

module.exports = {
  plugins: [
    new webpack.BannerPlugin({
      banner: '이것은 배너 입니다',
    })
  ]
```

생성자 함수에 전달하는 옵션 객체의 banner 속성에 문자열을 전달한다. 웹팩 컴파일 타임에 얻을 수 있는 정보, 가령 빌드 시간이나 커밋정보를 전달하기위해 함수로 전달할 수도 있다.

```js
new webpack.BannerPlugin({
  banner: () => `빌드 날짜: ${new Date().toLocaleString()}`,
})
```

배너 정보가 많다면 별로 파일로 분리하자.

```js
const banner = require("./banner.js")

new webpack.BannerPlugin(banner)
```

빌드 날짜 외에서 커밋 해쉬와 빌드한 유저 정보까지 추가해 보자.

`banner.js`:

```js
const childProcess = require("child_process")

module.exports = function banner() {
    // git commit 버전을 넣는다.
  const commit = childProcess.execSync("git rev-parse --short HEAD")
  //작성자를 넣는다.
  const user = childProcess.execSync("git config user.name")
  const date = new Date().toLocaleString()

  return (
    `commitVersion: ${commit}` + `Build Date: ${date}\n` + `Author: ${user}`
  )
}
```

빌드한뒤 플러그인이 처리한 결과는 다음과 같다.

![BannerPlugin](프론트엔드개발환경.assets/banner-plugin.jpg)

#### (2) DefinePlugin

어플리케이션은 개발환경과 운영환경으로 나눠서 운영한다. 가령 환경에 따라 API 서버 주소가 다를 수 있다. 같은 소스 코드를 두 환경에 배포하기 위해서는 이러한 **환경 의존적인 정보를 소스가 아닌 곳에서 관리하는 것이 좋다**. 배포할 때마다 코드를 수정하는 것은 곤란하기 때문이다.

웹팩은 이러한 환경 정보를 제공하기 위해 [DefinePlugin](https://webpack.js.org/plugins/define-plugin/)을 제공한다.

`webpack.config.js`

```js
const webpack = require("webpack")

export default {
  plugins: [new webpack.DefinePlugin({})],
}
```

빈 객체를 전달해도 기본적으로 넣어주는 값이 있다. 노드 환경정보인 `process.env.NODE_ENV `인데 웹팩 설정의 mode에 설정한 값이 여기에 들어간다. "development"를 설정했기 때문에 어플리케이션 코드에서 `process.env.NODE_ENV` 변수로 접근하면 "development" 값을 얻을 수 있다.

`app.js`

```js
console.log(process.env.NODE_ENV) // "development"
```

이 외에도 웹팩 컴파일 시간에 결정되는 값을 전역 상수 문자열로 어플리케이션에 주입할 수 있다.

```js
new webpack.DefinePlugin({
  TWO: "1+1",
})
```

TWO라는 전역 변수에 `1+1` 이란 코드 조각을 넣었다. 실제 어플리케이션 코드에서 이것을 출력해보면 2가 나올 것이다.

`app.js`

```js
console.log(TWO) // 2
```

코드가 아닌 값을 입력하려면 문자열화(`JSON.stringify`) 한 뒤 넘긴다.

```js
new webpack.DefinePlugin({
  VERSION: JSON.stringify("v.1.2.3"),
  PRODUCTION: JSON.stringify(false),
  MAX_COUNT: JSON.stringify(999),
  "api.domain": JSON.stringify("http://dev.api.domain.com"),
})
```

`app.js`:

```js
console.log(VERSION) // 'v.1.2.3'
console.log(PRODUCTION) // true
console.log(MAX_COUNT) // 999
console.log(api.domain) // 'http://dev.api.domain.com'
```

빌드 타임에 결정된 값을 어플리이션에 전달할 때는 이 플러그인을 사용하자.

#### (3) HtmlWebpackPlugin

이번엔 써드 파티 패키지에 대해 알아보자. [HtmlWebpackPlugin](https://github.com/jantimon/html-webpack-plugin/)은 HTML 파일을 후처리하는데 사용한다. 빌드 타임의 값을 넣거나 코드를 압축할수 있다.

먼저 패키지를 다운로드 한다.

```text
$ npm install -D html-webpack-plugin
```

이 플러그인으로 빌드하면 HTML파일로 아웃풋에 생성될 것이다. index.html 파일을 `src/index.html`로 옮긴뒤 다음과 같이 작성해 보자.

> index.html 파일을 src폴더 아래로 넣는다면 이미지 경로 또한 webpack.config.js에서 맞게 변경시켜줘야 된다.

`src/index.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>타이틀<%= env %></title>
  </head>
  <body>
    <!-- 로딩 스크립트 제거 -->
    <!-- <script src="dist/main.js"></script> -->
  </body>
</html>
```

타이틀 부분에 ejs 문법을 이용하는데 `<%= env %>` 는 전달받은 env 변수 값을 출력한다. HtmlWebpackPlugin은 이 변수에 데이터를 주입시켜 동적으로 HTML 코드를 생성한다.

뿐만 아니라 웹팩으로 빌드한 결과물을 자동으로 로딩하는 코드를 주입해 준다. 때문에 스크립트 로딩 코드도 제거했다.

`webpack.config.js`:

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports {
  plugins: [
    new HtmlWebpackPlugin({
        //옵션 전달
      template: './src/index.html', // 템플릿 경로를 지정
      templateParameters: { // 템플릿에 주입할 파라매터 변수 지정
        env: process.env.NODE_ENV === 'development' ? '(개발용)' : '',
      },
    })
  ]
}
```

환경 변수에 따라 타이틀 명 뒤에 "(개발용)" 문자열을 붙이거나 떼거나 하도록 했다. `NODE_ENV=development` 로 설정해서 빌드하면 빌드결과 "타이틀(개발용)"으로 나온다. `NODE_ENV=production` 으로 설정해서 빌드하면 빌드결과 "타이틀"로 나온다.

![HtmlWebpackPlugin](프론트엔드개발환경.assets/html-template-plugin.jpg)

개발 환경과 달리 운영 환경에서는 파일을 압축하고 불필요한 주석을 제거하는 것이 좋다.

`webpack.config.js`:

```js
new HtmlWebpackPlugin({
    // production일때만, 아닐때는 false로 끄기
  minify: process.env.NODE_ENV === 'production' ? {
    collapseWhitespace: true, // 빈칸 제거
    removeComments: true, // 주석 제거
  } : false,
}
```

([문서에는 minifiy 옵션이 웹팩 버전 3 기준으로 되어 있다](https://github.com/jantimon/html-webpack-plugin/issues/1094))

환경변수에 따라 minify 옵션을 켰다. `NODE_ENV=production npm run build`로 빌드하면 아래처럼 코드가 압축된다. 물론 주석도 제거 되었다.

![HtmlWebpackPlugin 2](프론트엔드개발환경.assets/html-template-plugin-2.jpg)

정적파일을 배포하면 즉각 브라우져에 반영되지 않는 경우가 있다. 브라우져 캐쉬가 원인일 경우가 있는데 이를 위한 예방 옵션도 있다.

`webpack.config.js`:

```js
new HtmlWebpackPlugin({
  hash: true, // 정적 파일을 불러올때 쿼리문자열에 웹팩 해쉬값을 추가한다
})
```

`hash: true` 옵션을 추가하면 빌드할 시 생성하는 해쉬값을 정적파일 로딩 주소의 쿼리 문자열로 붙여서 HTML을 생성한다.

![HtmlWebpackPlugin 3](프론트엔드개발환경.assets/html-template-plugin-3.jpg)

#### (4) CleanWebpackPlugin

[CleanWebpackPlugin](https://github.com/johnagan/clean-webpack-plugin)은 빌드 이전 결과물을 제거하는 플러그인이다. 빌드 결과물은 아웃풋 경로에 모이는데 과거 파일이 남아 있을수 있다. 이전 빌드내용이 덮여 씌여지면 상관없지만 그렇지 않으면 아웃풋 폴더에 여전히 남아 있을 수 있다.

임시로 아웃풋 폴더에 foo.js 파일을 만든 후 다시 빌드해 보면 아직 파일이 남아 있다.

![CleanWebpackPlugin](프론트엔드개발환경.assets/clean-webpack-plugin.jpg)이러한 현상을 CleanWebpackPlugin으로 해결해 보자. 먼저 패키지를 설치한다.

```text
$ npm install -D clean-webpack-plugin
```

웹팩 설정을 추가한다.

`webpack.config.js`:

```js
const { CleanWebpackPlugin } = require("clean-webpack-plugin")

module.exports = {
  plugins: [new CleanWebpackPlugin()],
}
```

빌드 결과 foo.js가 깨끗히 사라졌다. 아웃풋 폴더인 dist 폴더가 모두 삭제된후 결과물이 생성되었기 때문이다.

#### (5) MiniCssExtractPlugin

스타일시트가 점점 많아지면 하나의 자바스크립트 결과물로 만드는 것이 부담일 수 있다. 번들 결과에서 스트일시트 코드만 뽑아서 별도의 CSS 파일로 만들어 역할에 따라 파일을 분리하는 것이 좋다. 브라우져에서 큰 파일 하나를 내려받는 것 보다, 여러 개의 작은 파일을 동시에 다운로드하는 것이 더 빠르다.

개발 환경에서는 CSS를 하나의 모듈로 처리해도 상관없지만 프로덕션 환경에서는 분리하는 것이 효과적이다. [MiniCssExtractPlugin](https://github.com/webpack-contrib/mini-css-extract-plugin)은 CSS를 별로 파일로 뽑아내는 플러그인이다.

먼저 패키지를 설치한다.

```text
$ npm install -D mini-css-extract-plugin
```

웹팩 설정을 추가한다.

`webpack.config.js`:

```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin")

module.exports = {
  plugins: [
    ...(process.env.NODE_ENV === "production"
      ? [new MiniCssExtractPlugin({ filename: `[name].css` })]
      : []),
  ],
}
```

프로덕션 환경일 경우만 이 플러그인을 추가했다. `filename`에 설정한 값으로 아웃풋 경로에 CSS 파일이 생성될 것이다.

개발 환경에서는 css-loader에의해 자바스크립트 모듈로 변경된 스타일시트를 적용하기위해 style-loader를 사용했다. 반면 프로덕션 환경에서는 별도의 CSS 파일으로 추출하는 플러그인을 적용했으므로 다른 로더가 필요하다.

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          process.env.NODE_ENV === "production"
            ? MiniCssExtractPlugin.loader // 프로덕션 환경
            : "style-loader", // 개발 환경
          "css-loader",
        ],
      },
    ],
  },
}
```

플러그인에서 제공하는 MiniCssExtractPlugin.loader 로더를 추가한다.

`NODE_ENV=production npm run build`로 결과를 확인해보자.

![MiniCssExtractPlugin](프론트엔드개발환경.assets/mini-css-extract-plugin.jpg)

`dist/main.css`가 생성되었고 index.html에 이 파일을 로딩하는 코드가 추가되었다.

### 플러그인 실습

#### 플러그인을 추가해서 번들 결과를 만들어라. 

#### 1) BannerPlugin: 결과물에 빌드 시간을 출력

1. `wepack.config.js` 상단에 `const webpack = require("webpack");`을 가져옴
2. 하단에 plugins를 추가하여 BannerPlugin 생성자함수를 실행

```js
const webpack = require("webpack")

module.exports = {
  plugins: [
   new webpack.BannerPlugin({
       banner:`Build Time: ${new Date().toLocalString()}`
   })
  ],
}
```

3. `npm run build`로 확인
4. `dist`의 `main.js`에 웹팩을 실행했던 Build Time이 주석으로 적혀있다.

#### 2) HtmlWebpackPlugin: 동적으로 html파일을 생성

1.  webpack기본 플러그인이 아니라 따로 설치해야된다.
2. `npm install html-webpack-plugin`
3. `webpack.config.js`파일 상단에 가져오고, plugins배열에 추가한다.

> template 경로를 지정한 뒤, build를 하면 dist의 src폴더에 index.html body에 `<sript type="text/javascript" src="main.js"></script>`가 추가돼있다.

```js
const HtmlWebpackPlugin = require("html-webpack-plugin")

module.exports = {
  plugins: [
   new HtmlWebpackPlugin({
       // template경로를 지정 
       template: './src/index.html',
       templateParameters: {
           // env변수설정
           env: process.env.NODE_ENV === 'development' ? '(개발용)' : ''
       }
   })
  ],
}
```

4. HtmlWebpackPlugin에서 빌드 환경을 주입하기 위해서는 `index.html` `title`에  `ejs문법으로 <%= env %>`를 통해 build할 때`NODE_ENV=development npm run build`를 하면  `title`에  `(개발용)`으로 뜬다.

#### 3) CleanWebpackPlugin: 빌드 전에 아웃풋 폴더를 깨끗하게 정리

1. `npm install clean-webpack-plugin`을 통해 설치
2. `webpack.config.js`

```js
const {CleanWebpackPlugin} = require("clean-webpack-plugin")

module.exports = {
  plugins: [
   new CleanWebpackPlugin()
  ],
}
```



#### 4) MiniCssExtractPlugin: 모듈에서 css파일을 분리

1. `npm install mini-css-extract-plugin`
2. `webpack.config.js`

> build환경이 production일때만 실행되도록 한다.
>
> 이 플러그인은 로더도 설정해줘야된다.

```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin")

module.exports = {
  // 로더 설정 변경
  modules: {
      rules: [
          {
              test:/\.css$/,
              use: [
                  process.env.NODE_ENV === 'production' ? MiniCssExtractPlugin.loader : 'style-loader',
                  'css-loader'
              ]
          }
      ]
  },
  plugins: [
   ...(
       process.env.NODE_ENV === 'production' ? [new MiniCssExtractPlugin({
       // 생성될 파일의 이름
       filename:'[name].css'
   })] : []
  )
  ],
}
```

3. build를 하면 `main.css`가 나와있고, index.html head에 `<link href="main.css" rel="stylesheet">`가 자동으로 로딩 추가돼있다.



### 7. 정리

ECMAScript2015 이전에는 모듈을 만들기 위해 즉시실행함수와 네임스페이스 패턴을 사용했다. 이후 각 커뮤니티에서 모듈 시스템 스펙이 나왔고 웹팩은 ECMAScript2015 모듈시스템을 쉽게 사용하도록 돕는 역할을 한다.

엔트리포인트를 시작으로 연결되어 었는 모든 모듈을 하나로 합쳐서 결과물을 만드는 것이 웹팩의 역할이다. 자바스크립트 모듈 뿐만 아니라 스타일시트, 이미지 파일까지도 모듈로 제공해 주기 때문에 일관적으로 개발할 수 있다.

웹팩의 로더와 플러그인의 원리에 대해 살펴보았고 자주 사용하는 것들의 기본적인 사용법에 대해 익혔다.

