# 프론트엔드개발환경

[toc]

## 1. NPM

> [프론트엔드 개발환경의 이해 : NPM](https://jeonghwan-kim.github.io/series/2019/12/09/frontend-dev-env-npm.html)

### 1) 프론트엔드 개발에 Node.js가 필요한 이유?

- 최신 스펙으로 개발할 수 있다.
  - 자바스크립트 발전 > 브라우저 지원 속도
  - 웹팩, NPM 같은 노드 기술로 만들어진 환경에서 사용할 때 비로소 자동화된 프론트엔드 개발환경을 갖출 수 있다.
  - Typescript, SASS 또한 Node.js 환경이 뒷받침 되어야 된다.
- 빌드 자동화
  - 파일을 압축하고, 코드를 난독화하고, 폴리필을 추가하는 등 개발 이외의 작업을 거친 후 배포한다.
  - Node.js는 이런 빌드과정을 이해하게 하고, 라이브러리 의존성을 해결하고, 각종 테스트를 자동화하는데 사용된다.
- 개발 환경 커스터마이징
  - 커스터마이징을 하려면 Node.js 지식이 필요하다
  - Vue.js의 vue-cli, React.js의 CRA(create-react-app)를 사용하면 개발환경을 쉽게 갖출 수 있지만, 자동화된 도굴르 사용할 수 없는 환경이라면 직접 환경을 구축해야한다.

### 2) Node.js 설치

-  [Nodejs.org 사이트](https://nodejs.org/ko/)에서 노드 최신 버전을 설치가 가능하다.
- 짝수버전 : 안정적, 신뢰도 높음(LTS)
- 홀수버전 : 최신기능
- 개발환경이기 때문에 오른쪽 최신 버전을 선택해서 다운, Node.js로 서버를 구성하는 경우라면 어떤 버전을 사용할지 신중하게 선택(LTS)
- 터미널에 `node`를 치면 node.js를 쓸 수 있는`REPL(read-eval-print loop)` 프로그램이 실행됨
  - `.exit` 명령을 실행하거나 `ctrl + c`를 연속 두 번 입력하면 REPL 프로그램에서 빠져 나올 수 있다.

![image-20210527134313017](프론트엔드개발환경.assets/image-20210527134313017.png)

- Node를 설치하면 npm도 같이 설치된다.

### 3) 프로젝트 초기화

#### init

- `sample`폴더를 만든 뒤, 터미널에 `npm init`을 하면 프로젝트가 새로 생성된다.

```sh
$ npm init

package name:
version:
description:
entry point:
test command:
git repository:
keywords:
author:
license:
```

- 패키지 이름, 버전 등 프로젝트와 관련한 몇 가지 정보를 얻기 위한 질문을 볼 수 있다. 
- 답변하거나 혹은 빈 칸으로 남겨 두면 괄호 안의 기본값을 입력할 수 있다. 
- 모든 질문에 답하면 명령어를 실행한 폴더에 pacakge.json 파일이 생성된다. 
- 모두 기본값을 사용할 것이라면 `npm init -y` 명령어로 질문을 스킵하고 package.json 파일을 생성할 수 있다.

#### Package.json

- name: 프로젝트 이름
- version: 프로젝트 버전 정보
- description: 프로젝트 설명
- main: 노드 어플리케이션일 경우 진입점 경로. 프론트엔드 프로젝트일 경우 사용하지 않는다.
- scripts: 프로젝트 명령어를 등록할 수 있다.초기화시 test 명령어가 샘플로 등록되어 있다
- author: 프로그램 작성자
- license: 라이센스

```json
{
  "name": "sample",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
    // npm 명령어를 추가할 수 있다, 기본적으로 제공해주는 명령어 외에 추가하고 싶다면, scripts안에 추가!
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
      // 명령어추가
     "build" : "echo \"여기에 빌드 스크립트를 추가합니다\""
  },
  "author": "",
  "license": "ISC"
}
```

### 4) 프로젝트 명령어

- 기본적으로 제공해주는 명령어외에 추가하고 싶다면 `scripts`안에 추가한 뒤, `npm run 명령어`를 터미널창에 치면, 실행된다.
- test: echo 명령어로 메세지 "Error: no test specified"를 출력한뒤 에러 코드 1을 던지면서 종료하는 동작이다. 에러 코드 1을 확인하면 에러("npm ERR!...")를 출력한다.

![image-20210527134828652](프론트엔드개발환경.assets/image-20210527134828652.png)

![image-20210527135150865](프론트엔드개발환경.assets/image-20210527135150865.png)

#### NPM 명령어

- start: 어플리케이션 실행
- test: 테스트
- install: 패키지 설치
- uninstall: 패키지 삭제
- 프론트엔드 개발 환경을 구축하기 위해 추가할 스크립트는 build, lint 정도가 있다.
  - build: 소스 빌드
  - lint: 소스 컨벤션 검사

```sh
Usage: npm <command>

where <command> is one of:
    access, adduser, audit, bin, bugs, c, cache, ci, cit,
    clean-install, clean-install-test, completion, config,
    create, ddp, dedupe, deprecate, dist-tag, docs, doctor,
    edit, explore, get, help, help-search, hook, i, init,
    install, install-ci-test, install-test, it, link, list, ln,
    login, logout, ls, org, outdated, owner, pack, ping, prefix,
    profile, prune, publish, rb, rebuild, repo, restart, root,
    run, run-script, s, se, search, set, shrinkwrap, star,
    stars, start, stop, t, team, test, token, tst, un,
    uninstall, unpublish, unstar, up, update, v, version, view,
    whoami
```

### 5) 패키지 설치

#### CDN(컨텐츠 전송 네트워크)을 이용한 방법

- CDN 서버 장애로 인해 외부 라이브러리를 사용할 수 없다면  웹 어플리케이션은 정상적으로 동작하지 않을 것이다

#### 직접 다운로드하는 방법

- CDN을 사용하지 않기 때문에 장애와 독립적으로 웹 어플리케이션을 제공.

- 라이브러리는 계속해서 업데이트 될 것이고 우리 프로젝트에서도 최신 버전으로 교체해야 한다. 매번 직접 다운로드해야하며, 버전에 따라 하위 호환성 여부까지 확인하려면 실수할 여지가 많다.

#### NPM을 이용한 방법

- `npm install` 명령어로 외부 패키지를 우리 프로젝트 폴더에 다운로드가 된다.

```sh
$ npm install react
```

- 최신 버전의 react를 [NPM 저장소](https://www.npmjs.com/)에서 찾아 우리 프로젝트로 다운로드 하는 명령어다. package.json에는 설치한 패키지 정보를 기록한다.

- package.json:

```json
{
  "dependencies": {
   // 버전 16.12.0을 설치했다는 의미 
     "react": "^16.12.0"
  }
}
```

##### `^` : 유의적 버전

- 만약 프로젝트에서 사용하는 패키지의 버전을 엄격하게 제한한다면 사용하는 패키지를 전부 버전업해야 하기 때문에 프로젝트 버전업이 힘들 수 있고, 현재 버전에 갖혀 버릴 수도 있다.
- 반면에, 패키지 버전을 느슨하게 풀어 놓으면 오히려 여러 버전별로 코드를 관리해야하는 혼란스러움을 겪게될 수 있다.
- 버전번호를 관리하기 위한 규칙 **유의적 버전(Semetic-Version)** 이라고 한다.
- 유의적 버전은 주(Major), 부(Minor), 수(Patch) 세 가지 숫자를 조합해 버전을 관리한다.
  - 16.12.0 : 주 버전이 16, 부 버전이 12, 수 버전이 0이다.
  - 주 버전(Major Version): 기존 버전과 호환되지 않게 변경한 경우
  - 부 버전(Minor version): 기존 버전과 호환되면서 기능이 추가된 경우
  - 수 버전(Patch version): 기존 버전과 호환되면서 버그를 수정한 경우

#### 버전의 범위

- NPM이 버전을 관리하는 방식은 유의적 버전 명세 뿐만아니라 버전의 범위를 자신만의 규칙으로 관리
- 특정 버전보다 높거나 낮을 경우

```sh
>1.2.3
>=1.2.3
<1.2.3
<=1.2.3
```

- 틸드(`~`)와 캐럿(`^`)

  ##### 틸드(`~`)

  - 마이너 버전이 명시되어 있으면 패치버전만 변경
  - 예를 들어 ~1.2.3 표기는 1.2.3 부터 1.3.0 미만 까지를 포함한다. 
  - 마이너 버전이 없으면 마이너 버전을 갱신한다. ~0 표기는 0.0.0부터 1.0.0 미만 까지를 포함한다.

  ##### 캐럿(`^`)

  - 정식버전에서 마이너와 패치 버전을 변경한다. 
  - 예를 들어 ^1.2.3 표기는 1.2.3부터 2.0.0 미만 까지를 포함한다. 
  - 정식버전 미만인 0.x 버전은 패치만 갱신한다. ^0 표기는 0.0.0부터 0.1.0 미만 까지를 포함한다.

- 보통 라이브러리 정식 릴리즈 전에는 패키지 버전이 수시로 변한다.
  - 부버전이 변하더라도 하위 호환성을 지키지 않고 배포하는 경우가 빈번하다
  - `~0`으로 버전 범위를 표기하면 `0.0.0`부터 `1.0.0`미만까지 사용하기 때문에 하위 호완성을 지키지 못하는 `0.2`로도 업데이트 되어버리는 문제가 생길 수 있다.
  - 반면 `^0.0`으로 표기한다면 `0.0.0`부터 `0.1.0` 미만 내에서만 버전을 사용하도록 제한해 하위 호완성을 유지할 수 있다.
- NPM으로 패키지를 설치하면 `package.json`에 설치한 버전을 기록하는데 **캐럿 방식**을 이용한다.