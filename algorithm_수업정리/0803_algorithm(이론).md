알고리즘(APS)

> 유한한 단계를 통해 문제를 해결하기 위한 절차, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
>
> 어떠한 문제를 해결하기 위한 절차
>
> IM은 2중 for + list를 쓰면 풀림
>
> A는 완전검색+가지치기(백트래킹, 재귀이용) , 시뮬레이션 이용
>
> 알고리즘 배울때 절대 눈으로 하면 안됨 종이에 어떻게 알고리즘이 돌아가는지 써야됨 그리고 코드화 시켜야됨, 이해를 하려면 그림을 보통 많이 그림

## 알고리즘을 표현하는 방법

- 슈더코드(의사코드)와 순서도
- 정확성 : 얼마나 정확한가
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻는가
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
- 단순성 : 얼마나 단순한가
- 최적성 : 더이상 개선할 여지 없이 최적화되었는가

- 시간복잡도 = 빅-오(O) 표기법

  - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
  - 계수는 생략하여 표시

  ```sh
  O(3n+2) = O(3n) = O(n)
  O(2n^2 + 10n + 100) = O(n^2)
  O(4) = O(1)
  ```

  - n개의 데이터 입력받아 저장 후 1씩 증가시킨 후 각 데이터를  화면에 출력하는 알고리즘의 시간복잡도는 어떻게 되나? `O(n)`

- 다항식은 P문제

  - O(1), O(logn) : 이진탐색
  - O(n) : 순차탐색
  - O(nlogn) : quick, merge, heap
  - O(n^2) : 선택, 버블, 삽입

- 지수문제 NP문제(비다항식 NP !=non)

  - 현실적인 시간으로 안나옴, 근사알고리즘
  - O(2^n) : 부분집합, 조합
  - O(n!) : 순열 => 완전검색에서 나옴

- 알고리즘이 중요하다! N이 10억일때 NlogN보다 N^2은 300년이 넘게 걸림

## 배열(Array = list)

- 일정한 자료형(같은 자료형타입, 이름)의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

- 프로그램 내 여러개의 변수가 필요할 때, 다른 변수명을 이용하여 자료에 접근하는 것은 비효율적

- 하나의 선언을 통해 둘이상의 변수 선언 가능

- 다수의 변수선언 의미 X, 다수의 변수로 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있음

- 1차원 배열의 선언

  - 별도의 선언방법이 없으면 변수에 처음 값을 할당할 때 생성
  - 이름 : 프로그램에서 사용할 배열의 이름

  ```sh 
  Arr = list()
  Arr = [](1차원 배열 선언의 예)
  Arr[idx] = 10;//배열 Arr의 idx번째 원소에 10을 저장하라
  ```

- code / data : 전역,정적 변수 / heap:참조형변수 ex)배열 / stack:지역변수
- 배열 활용 예제(IM정도)



## 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰갑(오름차순) 혹은 그 반대의 순서(내림차순)로 재배열하는 것
- 키 : 자료를 정렬하는 기준이 되는 특정 값
- 정렬 방식 종류
  - 버블, 선택, 삽입 정렬 O(n^2)
  - 카운팅 정렬 O(n+k)
  - 퀵, 병합 정렬 O(nlogn)

### 1) 버블정렬

- 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식
- 정렬 과정
  - 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다

- 시간 복잡도 : O(n^2)
- 비교환방식, 코딩이 가장 손쉽다

```sh
n=5(원소 몇개), 4pass 각 pass는 4번, 3번,2번,1번
1pass
(55 7) 78 12 42
7 (55 78) 12 42
7 55 (78 12) 42
7 55 12 (78 42)
7 55 12 42 78

2pass
(7 55) 12 42 78
7 (55 12) 42 78
7 12 (55 42) 78
7 12 42 55 78

3pass
(7 12) 42 55 78
7 (12 42) 55 78
7 12 42 55 78

4pass
(7 12) 42 55 78
7 12 42 55 78
```

- 코드화

```python
def Bubblesort(a): #정렬할 List
	for i in range(len(a)-1,0,-1): #범위의 끝 위치 4,3,2,1
       for j in range(0,i) :
           if a[j] > a[j+1]:
               a[j],a[j+1] = a[j+1],a[j] #swap
               #t=A ,A=B, B=t C나 java는 이렇게 swap함
```

- 파이참에서 디버깅 마우스오른쪽 버튼 dibug누르면 하나씩 값이 들어가면서 디버깅되는 것을 보여줌 프로그램이 안돌면 디버깅하면서 차근차근 풀기



## 2) 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 셈
- 선형 시간에 정렬하는 효율적인 알고리즘
- O(n+k) : n은 리스트 길이, k는 정수의 최대값
- 정수로 표현할 수 있는 자료에 대해서만 적용(문자1개-아스키코드로 작성 가능, 문자열X, 실수X(소수점2자리까지 있는건 가능*100)) : 각 항목의 발생 회수를 기록하기 위함
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 비교환방식, n이 비교적 작을 때만 가능하다

```python
#A[] 입력배열 DATA
#B[] 정렬된 배열 COUNTS
#C[] 카운트배열(누적합) TEMP
def Counting_Sort(A,B,k): #k최대값
    C = [0] * k #최대값만큼의 리스트 개수
    #1.카운팅
    for i in range(0,len(B)):
        C[A[i]] += 1
    #2.누적
    for i in range (1,len(C)):
        C[i] += C[i-1] #C[i] = C[i] +C[i-1]
    #3.소트
    for i in range(len(B)-1,-1,-1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1
a = [0,4,1,3,1,2,4,1]#소스
b = [0] *len(a)#결과저장 배열
Counting_Sort(a,b,4+1)
print(a)
print(b)
```

#### 카운팅 정렬 이해하기!!

1. A에서 숫자 순서대로 몇 번 등장하는지 세어줌(`#카운팅단계`, idx가 해당 숫자)

```sh
A = [0,4,1,3,1,2,4,1] => C = [1,3,1,1,2]
```

2. 등장 횟수를 누적합으로 바꿔줌. (`#누적단계`)
   - 이 누적합에서 알 수 있는 것은 숫자 0은 (0:1), 1은 (1,4), 2는 (4,5), 3은 (5,6), 8은 (6,8) idx에 위치하고 있다는 것을 알 수 있음.

```sh
C = [1,3,1,1,2] => C = [1,4,5,6,8]
```

3. 정렬한 배열 A를 뒤에서 앞으로 순회하면서 정렬된B에 넣어줌.(`#소트단계` )
   - 2번의 누적합이 배열 A의 숫자가 배열 B의 어디에 위치해야 할지 알려줌.

```sh
i=7(len(B)-1)일때 #idx는 0부터 시작하기 때문에 1을 빼줌
A[7] = 1 -> C[1] = 4 #누적합을 통해 1은 B의 4번째 idx에 위치한다는 것을 알 수 있음
B[4-1] = A[7] #4번째 idx에 위치하려면 0부터 시작하기 때문에 1빼줌, 그 자리에 A[7]인 1이 위치함
C[A[7]] -= 1 #다음에 올 숫자 1은 그 앞자리에 와야되므로 누적합을 -1로 해줌
#이게 뒤에서부터 앞으로 순회하는 이유, 제일 끝 위치에 먼저 위치시키고 -1하며 앞에 정렬하게 함, 그렇게 순서대로 나열을 시킴

## 이것을 i=0까지 반복함
```

- `Counting Sort`는 시간복잡도가 `Quick Sort`보다 훨씬 유리해보이지만 대부분의 상황에서 엄청난 `메모리 낭비`를 할 수 있다.

- 정렬하는 숫자가 `특정한 범위`안에 있을 때 사용함

## 완전검색

- 모든 경우의 수를 나열해보고 확인하는 기법
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출
- 일반적으로 경우의 수가 작을 때 유용
- 속도는 느리지만 해답을 찾아낼 확률이 높다!
- `**중요**`자격검정평가 등 주어진 문제를 풀 때, 우선 완전검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘(ex 가지치기하기 위해선 완전검색을 재귀로 해야 됨=`dfs` => `BT(백트래킹)`)을 사용하고 해답을 확인하는 것이 바람직함(`IM` X `A형` O)

#### 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열
- 서로 다른 n개 중 r개를 택하는 순열 `nPr`
- nPn = n!

```python
#{1,2,3}을 포함하는 모든 순열을 생성하는 함수
#원소개수가 늘어날수록 for문이 늘어남...재귀로 푸는게 좋음
for i1 in range(1,4):
    for i2 in range(1,4):
        if i2 != i1:
            for i3 in range(1,4):
                if i3 != i1 and i3 != i2:
                    print(i1,i2,i3)
```



#### Baby-gin Game

- 비복원추출(임의의카드 6장 뽑음), 3장의 카드가 연속적인 번호를 가지면 run
- 3장의 카드가 동일한 번호를 가지면 triplet
- 6장의 카드가 run과 triplet으로만 구성된 경우를 baby-gin이라 함
- 6자리 숫자를 입력받아 baby-gin여부를 판단하는 프로그램 작성

- 6장 => 모든 경우의 수를 다 따져봐 판단하기
- ex) 66767 => (666,777) triplet이라 baby-gin
- 완전검색으로 찾아보자!

- 모든 경우의 수 순열 나열 6! = 720개



## 탐욕(Greedy)알고리즘

- 최적해(답이 여러개 있을 때 제일 좋은 것)를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장이 없다
- 보통 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 하는 접근을 말함

- 되도록이면 완전검색을 써라!(쓰지말라는 건 아님 경우에 따라 다르다!)
- 완전검색은 시간이 많이 들기 때문에 시간초과가 될 수 있음

#### 거스름돈 줄이기

- 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄여라
- 제일 큰 동전부터 넣어서 빼보고 안된다면 그다음 액수의 동전을 본다 거스름돈으로 드려야 할 액수 같은지 확인
- if 400원짜리 동전이 있다고 가정한다면 500먼저 했을 때 100원짜리와 함께 4개의 동전이 필요함, 답은 400원짜리 2개인데.... 그래서 그리디 알고리즘은 안되는 경우도 많음 => 완전검색으로 해라!!!

- Babygin 탐욕으로 풀리긴 함..하지만 안되는 경우 다수 존재 (but **순열로 풀어보기!!!)
- counting으로도 구해지긴하고 안구해지기도 함 (10으로 나눈 나머지, 몫을 이용해서 counting을 통해 구함-while문 사용)

```python
num = 456789 #Baby Gin 확인할 6자리 수
c = [0] * 12 #6자리수로부터 각 자리 수를 추출하여 개수를 누적할 리스트 idx넘어서면(+2까지 하는것이 있어서) 오류가 나기때문에 12개로 2개 idx더 첨가함
for i in range(6):
    c[num%10] += 1
    num //= 10
i = 0
tri = run = 0
while i<10:
    if c[i] >= 3: #triplete조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        continue # 같은것이 반복되면 두번 돌기 때문에 ex_123123 run,triplet둘다 확인하려고
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue

    i +=1

if tri + run == 2 : print('Baby Gin')
else : print('Lose')
```



#### 낙차가 큰 값 구하기

- max나 min은 가장 최소값, 가장 최대값을 지정해줘야됨

```python
data = [7,4,2,0,0,6,0,7,0] #오른쪽에서 자기보다 작은쪽의 개수를 세면 그 개수가 낙차가 된다. 중력으로 떨어지기 때문에 왼쪽은 셀 필요 없음 자기보다 하나 큰 idx부터 끝까지
max = 0

for i in range(9): #idx가 0부터 8번까지 있음
    cnt = 0
    for j in range(i+1,9): #자기보다 1큰 idx부터 끝까지 중 자기보다 작은 것의 수를 계산 
        if data[i] > data[j]:
            cnt += 1
    if max < cnt:#구해지는 낙차값중 가장 큰 최대값을 찾아라
        max = cnt
print(max) #7
```

 

## 데일리 문제

- 왼쪽 오른쪽이 2칸이상 비어있어야 조망권 확보
- 가로길이는 항상 1000이하
- 맨 왼쪽 두 칸과 오른쪽 두칸은 건물이 지어지지 않고 비어있다
- 각 빌딩 높이는 최대 255이다
- 입력값 첫 번째 줄 테스트케이스가 주어지고
- 그 바로 다음 줄에 테스트케이스가 주어짐
- #테스트케이스 번호, 조망권 확보 세대의 수를 구하면 됨

- 오른쪽 두칸 왼쪽 두칸과 비교해서 가장 큰 최대값 높이만큼 빼면 조망권 확보된 세대수가 나옴
- 자기중심 오른쪽 두개 왼쪽두개 4칸 중 최대값을 찾고 현재 i idx보다 작으면 자기 값-최대값 세대 조망권 확보, 아니면 없다.

```python
#해설
#for문이 10개 돌도록 해줘야됨 총 10개 테스트케이스라고 했음
#테스트케이스는 주어지는 값의 길이이다.
for tc in range(1,11):1~10까지 테스트케이스를
    N = int(input())
    arr = list(map(int,input().split()))#입력받을 곳
    cnt = 0
    
    for i in range(2,N-2):#앞두개 뒤두개는 0이다
        MAX = max(arr[i-2],arr[i-1],arr[i+1],arr[i+2])
        if arr[i] > MAX:
            cnt += (arr[i]-MAX)
            
    print('#{} {}'.format(tc, cnt))
```

