# Algorithm

## SW문제 해결

1. 문제를 읽고 이해한다
2. 문제를 익숙한 용어로 재정의함
3. 어떻게 해결할지 계획을 세움
4. 계획을 검증함
5. 프로그램으로 구현
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아봄



- 문제 해결 전략
  - 직관과 체계적인 접근
- 체계적인 접근 위한 질문들
  - 비슷한 문제를 풀어본 적이 있던가?
  - 단순한 방법에서 시작할 수 있을까?
  - 문제를 단순화 할 수 있을까?
  - 그림으로 그려 볼 수 있을까?
  - 수식으로 표현할 수 있을까?
  - 문제를 분해 할 수 있을까?
  - 뒤에서부터 생각해서 문제를 풀 수 있을까?
  - 특정 형태의 답만을 고려할수 있을까?



## 복잡도 분석

- 알고리즘?
  - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
  - 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함
  - 간단하게 다시 말하면 어떤 문제를 해결하기 위한 절차라고 볼 수 있음
- 알고리즘의 효율
  - 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말함
    - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말함
    - 효율성을 뒤집어 표현하면 복잡도가 됨
    - 복잡도가 높을수록 효율성은 저하됨
  - 시간적 복잡도 분석
    - 하드웨어 환경에 따라 처리시간이 달라짐
      - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
      - 입출력 장비의 성능, 공유여부
    - 소프트웨어 환경에 따라 처리시간이 달라짐
      - 프로그램 언어의 종류
      - 운영체제, 컴파일러의 종류
    - 이러한 환경적차이로 분석이 어렵다

- 복잡도의 점근적 표기
  - 시간(또는 공간)복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러개의 항을 가지는 다항식이다.
  - 이를 단순한 함수로 표현하기 위해 점근적 표기(Asympototic Notation)를 사용한다.
  - 입력크기n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
    - Big-Oh 표기
      - (최악의 경우...)
    - Big-Omega표기
      - (잘해봤자...)
    - Big-Theta표기
      - (항상 이만큼...)

### O(Big-Oh)표기

- O-표기는 복잡도의 점근적 상한을 나타낸다.
- 복잡도가 f(n) = 2^(n^2)+7n +4이라면, f(n)의 O-표기는 O(n^2)이다.
- 먼저 f(n)의 단순화된 표현은 n^2이다.
- 단순화된 함수 n^2에 임의의 상수 c를 곱한 c*n^2이 증가함에 따라 f(n)의 상한이 된다(c>0)

![image-20201023143315619](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201023143315619.png)

- 복잡도 f(n)과 O-표기를 그래프로 나타내고 있다
- n이 증가함에 따라 O(g(n))이 점근적 상한이라는 것 (즉, g(n)이 n0보다 큰 모든 n에 대해서 항상 f(n)보다 크다는 것)을 보여줌

![image-20201023143501363](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201023143501363.png)



#### 자주사용하는 O-표기

| O-표기   | 뜻                      |
| -------- | ----------------------- |
| O(1)     | 상수시간(Constant time) |
| O(logn)  | 로그(대수)시간          |
| O(n)     | 선형시간                |
| O(nlogn) | 로그 선형 시간          |
| O(n^2)   | 제곱시간                |
| O(n^3)   | 세제곱시간              |
| O(2^n)   | 지수시간                |







### Big-Omega 표기

- 복잡도의 점근적 하한을 의미한다
- f(n)=2^(n^2)-7n+4의 Big-Omega표기는 오메가(n^2)이다.
- f(n)=오메가(n^2)은 'n이 증가함에 따라 2*(n^2)-7n+4'이 cn^2보다 작을 수 없다' 라는 의미이다. 이때 상수 c=1로 놓으면 됨
- O-표기 때와 마찬가지로 오메가-표기도 복잡도 다항식의 최고차항만 계속 없이 취하면 된다.
- ***"최소한 이만한 시간은 걸린다."***

- 복잡도 f(n)과 오메가-표기를 그래프로 나타낸 것인데, n이 증가함에 따라 오메가(g(n))이 점근적 하한이라는 것 (즉, g(n)이 n0보다 큰 모든 n에 대해서 항상 f(n)보다 작다는 것)을 보여줌 

![image-20201023143834164](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201023143834164.png)



### Theta-표기

- O-표기와 오메가-표기가 같은 경우에 사용

- f(n)= 2*(n^2) + 8n + 3 = O(n^2)=오메가(n^2)이므로, f(n)=theta(n^2)이다.

- 'f(n)은 n이 증가함에 따라 ***n^2과 동일한 증가율을 가진다***라는 의미

  

![image-20201023144038263](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201023144038263.png)



### 왜 효율적인 알고리즘이 필요한가?

- 10억개의 숫자를 정렬하는데 PC에서 O(n^2)알고리즘은 300여년이 걸리는 것을 반년에 O(nlogn) 알고리즘은 5분만에 정렬됨
- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.



## 표준 입출력 방법

- 출력
  - print()
    - 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
  - print('text',end='')
    - 출력 시 마지막에 개행문자 제외할 시
  - print('%d'% number)
    - Formatting된 출력
- 파일의 내용을 표준 입력으로 읽어오는 방법
  - import sys
  - sys.stdin = open('a.txt','r')



## 비트연산

- 비트연산자

| 비트연산자 | 연산자의 기능                                      |
| ---------- | -------------------------------------------------- |
| `&`        | 비트단위로 AND연산을 한다                          |
| `|`        | 비트단위로 OR연산을 한다                           |
| `^`        | 비트단위로 XOR연산을 한다.(같으면 0  다르면 1)     |
| `~`        | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. |
| `<<`       | 피연산자의 비트 열을 왼쪽으로 이동시킨다.          |
| `>>`       | 피연산자의 비트 열을 오른쪽으로 이동시킨다.        |

- `1<<n`
  - 2^n의 값을 갖는다.
  - 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
  - Power set(모든 부분 집합)
    - 공집합과 자기 자신을 포함한 모든 부분집합
    - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.
- `i & (1 << j)`
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미함



### 엔디안(Endianness)

- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW아키텍처마다 다르다.
- 주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류를 발생시킬 수 있다.

- 크게 두가지로 나뉨

#### 빅엔디안(Big-endian)

- 보통 큰 단위가 앞에 나옴, 네트워크

#### 리틀 엔디안(Little-endian)

- 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터

| 종류        | 0x1234의 표현 | 0x12345678의 표현 |
| ----------- | ------------- | ----------------- |
| 빅엔디안    | 12 34         | 12 34 56 78       |
| 리틀 엔디안 | 34 12         | 7856 34 12        |

- 엔디안 확인 코드

```python
n = 0x00111111
if n & 0xff:
    print('little endian')
else:
    print('big endian')
```

- 엔디안 변환코드

> 바이트 단위로 나눈다음, 바이트끼리 순서를 바꾸자! 
>
> 그 연산을 어떻게 하는가?
>
> 실제로 이렇게 만든다음에 저장을 하면 빠른 번호에 들어가는 주소가 맞바뀜

```python
x = 0x01020304
p=[]
for i in range(0,4):
    p.append((x >> (i*8)) & 0xff)
print('x = %d%d%d%d'% (p[0],p[1],p[2],p[3]))
p = ce(x)
print('x = %d%d%d%d'% (p[0],p[1],p[2],p[3]))
```

- 엔디안 변환코드

```python
def ce(n): #change endian
    p = []
    for i in range(0,4):
        p.append((n >> (24-i*8)) & 0xff)
    return p
```



```python
def ce1(n):
    return (n << 24 & 0xff000000) | (n << 8 & 0xff0000) | (n >> 8 & 0xff00) | (n >> 24 & 0xff)
```



- 비트 연산 예제5

> 비트연산자 `^` 를 두 번 연산하면 처음 값을 반환한다.

```python
def Bbit_print(i):
    output = ''
    for j in range(7,-1,-1):
        output += '1' if i & (1 << j) else '0'
    print(output)
a = 0x86
key = 0xAA

print('a	==>',end='')
Bbit_print(a)

print('a^=key	==>', end ='')
a ^= key;
Bbit_print(a)

print('a^key ==>',end='');
a ^=key;
Bbit_print(a)
```

![image-20201026105253134](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201026105253134.png)





## 진수

- 2진수,8진수,10진수,16진수
- 10진수 -> 타진수로 변환
  - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
  - (149)10 = (10010101)2 = (225)8 = (95)16

- 컴퓨터에어스이 음의 정수 표현 방법
  - 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환한다.
    - -6: 1000000000000110 : 부호와 절대값 표현
    - -6 :1111111111111001: 1의 보수 표현
  - 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.
    - -6: 11111111111111010: 2의 보수 표현



## 실수

- 실수의 표현
- 소수점 이하 4자리를 10진수로 나타내보면

![image-20201026111216437](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201026111216437.png)



### 실수의 표현

- 컴퓨터는 실수를 표현하기 위해 부동 소수점 표기법을 사용한다
- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.
  - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
- 실수를 저장하기 위한 형식
  - 단정도 실수(32비트)
  - 배정도 실수(64비트)

![image-20201026111945345](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201026111945345.png)

- 가수부(mantissa): 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
- 지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것



#### 단정도 실수의 가수 부분을 만드는 방법

- 예 : 1001.001
- 정수부의 첫번째 자리가 1이 되도록 오른쪽으로 시프트
- 소수점 이하를 23비트로 만든다
- 소수점 이하만을 가수 부분에 저장
- 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소

#### 단정도 실수의 지수부분을 만드는 방법

- 지수부에는 8비트가 배정(256개의 상태를 나타낼 수 있음)
- 숫자로는 0-255까지 나타낼 수 있지만, 음수 값을 나타낼 수 있어야 하므로 익세스(excess)표현법을 사용
  - 익세스 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

![image-20201026112413033](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201026112413033.png)

- 컴퓨터는 실수를 근사적으로 표현한다.
  - 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴
- 실수 자료형의 유효 자릿수를 알아두자.
  - 32비트 실수형 유효자릿수(십진수) => 6
  - 64비트 실수형 유효자릿수(십진수) =>15

### 파이썬에서의 실수 표현 범위

- 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.
- 최대로 표현할 수 있는 값은 약 1.8 x 10^308이고 이 이상은 inf로 표현
- 최소로 표현할 수 있는 값은 약 5.0x10^(-324)이며, 이 이하는 0으로 표현



## 연습문제2_16진수를 10진수로

```python
'''
01D06079861D79F99F
'''

def binary(num):
    global result,cnt
    if num == 0:
        return result
    result[3-cnt] = str(num%2)
    num //= 2
    cnt+=1
    binary(num)

alpha = {'A':10,'B':11,'C':12,'D':13,'E':14,'F':15}
bit = input()
#16진수는 각자리수를 2진수로 바꿔주면 2진수로 바뀜!!
nums = ''
for b in bit:
    result = ['0']*4
    cnt = 0
    #알파벳은 수로 변환
    if b.isalpha():
        for a in alpha:
            val = alpha[b]
        binary(val)
        nums += ''.join(result)
        continue
    binary(int(b))
    nums += ''.join(result)
for n in range(0,len(nums),7):
    words = nums[n:n+7]
    temp = 0
    for w in range(len(words)):
        word = words[len(words)-w-1]
        if int(word):
            temp += 2**w
    print(temp,end=' ')
```

